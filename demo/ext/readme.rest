Creating a Facebook-like Url submission tool with Embedly

One of our clients is currently using Ext and Embedly to implement a Facebook-like 
link submission tool. While coding up so examples there is good reason to
share this with the community as a whole. Herein lies the bible of Ext and
Embedly.

First off note that I am not an Ext expert. In fact this is the first I have
ever used the tool. While I disagree with it's obsession with ids I like how
it creates HTML and fly. If you see anything that is off or just looks wrong,
blame ignorance.

First off we are trying to build a fairly common design pattern that allows
users to preview the info for a link before submitting it to their feed. Below
are a few screenshots from various different services

Facebook

.. image:: https://github.com/embedly/embedly-docs/raw/master/demo/ext/images/facebook.png

Yammer (Uses Embedly)

.. image:: https://github.com/embedly/embedly-docs/raw/master/demo/ext/images/yammer.png

Google+

.. image:: https://github.com/embedly/embedly-docs/raw/master/demo/ext/images/googleplus.png

They are all pretty even when it comes down to it, but you can definitely see
that the 1st selected image for each are all different. Well why is that? Well
the `10k Apart <http://10k.aneventapart.com/>`_ site doesn't specify an
``image_src`` or ``og:image`` tag in the head of the html so it's everyman for
themselves. I can tell you that Embedly looks for the main content div then
examines all the images within and scores them according to a number of
different factors. The others do the same, but with different scoring
algorithms.

When it comes down to it though, it should be up to the user. Any of the three
could work, but at the end of the day a user, not code, will always choose the
best image. So the task is simple, create a form that allows a user to input a
URL and select the thumbnail they wish to show. There are however a bunch of
other considerations that you will invariable end up coming across that we will
look at as well.

One of Embedly's API endpoints was specifically made for this task. The 
`preview endpoint <http://embed.ly/docs/endpoints/1/preview>`_ expands on
oEmbed and passes back an array of images, content, place information, event
details as well as the normal oEmbed html data. It holds a lot of information,
but we are going to use the following attributes. I'm going to go into detail
here because I think it's import that you know where the data is coming from
and how to use it.


type
    
    The type of the response that we got back from the server. %90 of the time
    you will get back a ``type`` of ``html``, but another very common one is
    ``image``. There is a whole list of `response types 
    <http://embed.ly/docs/endpoints/response#response-types>`_, but generally
    most people code for ``html`` and ``image`` and give up on the other types.
    Later we will go through what that actually means.

title

    Title of the page. Embedly looks for a title in the API response, the Open
    Graph title tag or the ``<title>`` tag in the head of the doc in that order
    . For 10k.aneventapart.com we found the title tag::
    
        <title>10K Apart - An Event Apart + Mix Online</title>

description

    A description or brief excerpt from the page. Embedly looks for a title in
    the API response, the Open Graph description, the
    ``<meta name="description">`` tag in the head of the doc in that order. If
    none of those exist, or are too short, Embedly will use an algorithm to try
    to find a good excerpt from the page. It does this by looking for common
    clues like a string of p tags, divs with lots of text at a simliar depths
    and a whole slue of other facters.
   
    Going back to the Facebook, Google+ and Yammer examples above here are the
    descriptions that each give back
   
    Facebook:: 
    
        ''

    Google +:: 
     
        10k Apart Responsive Edition. Inspire the Web with Just 10k. Read the
        Rules Submit an Entry. The Gallery. 1-1 of 1. Launch Details. Colorrrs.
        Colorrrs. Dave Rupert. Enter Now. Enter Now. The Rules (FA...

    Yammer (Embedly)::
   
        Total file size including images, scripts & markup can't be over 10k
        zipped. Details Use the approved list of libraries without it counting
        against your 10K. Details We encourage HTML5, and apps must work
        equally well in IE10 PP2, Firefox & a Webkit browser. Details
        Applications need to be responsive.
        
    As you can see Facebook gave up and was unable to pull a description.
    Google found the best first line, but quickly degrades to a bunch of
    nonsense. Embedly found the largest body of text and tried to use that.
    It's the longest and respects sentence structure, but the description of
    the rules, not of the contest itself. The fun thing is, if you visit the
    page, none of this text is initially viewable to the user. It's in divs
    that are hidden by css, and therefore we have no way of knowing if they are
    displayed or not.
    
    A user could easily intervene, edit the description to something that made
    a little more sense. As a side note, it's really hard to pull good excerpts
    all the time, it's harder to know when to not show one at all.

images

    This is a JSON array of images of possible thumbnails for the user to
    select. For 10k.aneventapart.com, the json array looks like this::

        [
          {
            "url": "http://10k.aneventapart.com/Uploads/501/Thumbnail1.jpg", 
            "width": 600, 
            "height": 400
          },
          {
            "url": "http://10k.aneventapart.com/Content/img/enter_now.jpg", 
            "width": 600, 
            "height": 400
          }, 
          {
            "url": "http://10k.aneventapart.com/Content/img/10k_logo.png", 
            "width": 235, 
            "height": 144
          }
        ]

    As you can see Embedly values the larger images in the middle of the page
    greater than the smaller logo at the top of the page. Within the middle of
    the page we value images that appear higher in order.
    
    Images are pulled from a bunch of different sources: API responses, the
    Open Graph image tag, the `image_src` link tag and the page itself. Embedly
    follows all these image to get the correct height, width and verify that
    they exist. Scoring these images is really complicated. Each image is
    scored based on where they lie in the page, what the image type is, if they
    matched a list of commonly used ad servers, did the image redirect and a
    whole slew of other factors that have been added over time.
    
    Still with all these factors, it's hard to pick the right image every time.
    

provider_display

    ``provider_display`` is different from oEmbed's ``provider_name``. It is a
    very easy way to display just the domain of the provider. For example,
    ``http://www.bbc.co.uk/news/science-environment-14391929`` has a provider
    display of ``www.bbc.co.uk`. It's just an easy way of showing a user what
    domain they will be visiting.

provider_url

    ``provider_url`` works in conjunction with ``provider_display``. It's the
    URL of the provider. Most of the time you can use it to link to the
    provider like so::
    
        <a href="{{provider_url}}">{{provider_display}}</a>

object

    ``object`` is fairly similar to an oEmbed object, but striped down. The
    idea here is that there is an object associated with the url that you
    passed to Embedly. There are three types: ``photo``, ``video`` and ``rich``
    . ``video`` and ``rich`` can be treated the same code wise when displaying
    the embed. The ``html`` element can just be set to the innerHTML of the
    feed item. Here is a simple example in js:
    
        if (preview.object.type in {'video':'', 'rich':''}){
           Ext.fly('item').dom.innerHtml = preview.object.html;
        }
    
    The ``photo`` is a little different in that it there is no ``html``
    attribute, but a URL instead. You can very easily use it to build the html
    though::
    
        if (preview.object.type == 'image'){
           Ext.fly('item').dom.innerHtml = '<img src="'+preview.object.url'"/>';
        }
    
    Not that we are *not* using the width and height attributes on the ``img``
    tag. The images that are passed back are all different sizes so, it's best
    to use the css style ``max-width`` like so::
    
        #item img {
            max-width:400px;
        }
    
    Don't bother messing with the height. People know how to scroll, so designs
    that are tolerate to different heights of images are the best.

While the Preview endpoint passes back more metadata including content, events,
places and embeds we will not be using that for this demo. We want to make this
simple and allow people to build from there.

There are two sections to the feed; retrieval and display. Retrieval is the
long section that describes grabbing metadata from Embedly and allowing the
user to edit it before submission. Display is much shorter and just goes into
tips and tricks for displaying the data.

We start off with the following simple form::

    <form action="." method="post">
        <textarea id="id_status" name="status">
        </textarea>
        <input type="submit" value="submit"/>
    </form>

And then the base for our Preview obj that we will use to wire up all the
supporting functions. You can use any of the 20 different object declaration
patterns in JavaScript, ours just happens to look like this::

    var Preview = (function(){
      var Preview = {};
      return Preview;
    })();

A user will come to your site in hopes of posting a status of some sort. In
this status may contain a link. There are a few events that we need to listen
to here in order to create the desired effect: ``paste``, ``blur`` and
``keyup``.

paste
    
    Easily the most common way that users move links around. The event fires
    after anything is pasted into the object you are listening to. In Ext you
    can listen to the event like so::
    
        Ext.EventManager.on("id_status", 'paste', Preview.fetchMetadata);
    
    The ``paste`` event is a little inconsitant however and at least in Chrome
    actually fires before the ``textarea`` is filled. Because of that it's
    better to set a short timeout to make sure the pasted value is there::
    
        Ext.EventManager.on("id_status", 'paste', function(){
            setTimeout(Preview.fetchMetadata, 250);
        });

blur

    When the the status box loses focus we need to check if the user added
    anything to it. While ``keyup`` and ``paste`` will catch 95% of the cases
    this one is nice to have::
    
        Ext.EventManager.on("id_status", 'blur', Preview.fetchMetadata);

keyup

    If a user wants to be so bold that they actually type in the URL we want to
    fetch it as soon as they hit the spacebar. This one is a little more tricky
    because if they are manually typing a url they may edit it a few times
    causing repeat calls. While we are not going to worry about that here it's
    just something to think about.
    
        Ext.EventManager.on("id_status", 'blur', Preview.onKeyUp);
    
    The ``onKeyUp`` function has a different set of rules than just
    ``fetchMetadata`` as we have to listen for just the spacebar after a URL
    has been entered::

        onKeyUp : function(e,t){
          // Ignore Everthing but the spacebar Key event.
          if (e.getKey() != 32) return null;

          //See if there is a url in the status textarea
          var url = Preview.getStatusUrl();
          if (url == null) return null;
  
          // If there is a url, then we need to unbind the event so it doesn't
          // fire again. This is very common for all status updaters as
          // otherwise it would create a ton of unwanted requests.
          Ext.EventManager.un("id_status", 'keyup', Preview.onKeyUp);
  
          //Fire the fetch metadata function
          Preview.fetchMetadata();
        },

    The ``unbind`` is very important here. A user may go back and edit the URL
    a hundred times here. We assume they got it right the first time, otherwise
    we will update the URL when the textarea loses focus.


